{"version":3,"sources":["/home/runner/work/zora-protocol-private/zora-protocol-private/packages/coins-sdk/dist/index.cjs","../src/actions/createCoin.ts","../src/utils/validateClientNetwork.ts","../src/metadata/cleanAndValidateMetadataURI.ts","../src/metadata/validateMetadataJSON.ts","../src/metadata/validateMetadataURIContent.ts","../src/utils/getChainFromId.ts","../src/client/client.gen.ts","../src/client/sdk.gen.ts","../src/api/api-key.ts","../src/api/explore.ts","../src/api/queries.ts","../src/api/create.ts","../src/utils/rethrowDecodedRevert.ts","../src/actions/updateCoinURI.ts","../src/utils/attribution.ts","../src/actions/updatePayoutRecipient.ts","../src/actions/tradeCoin.ts","../src/uploader/metadata.ts","../src/api/internal.ts","../src/uploader/providers/zora.ts"],"names":["base","baseSepolia","getCoin","getCoins","getCoinHolders","getCoinSwaps","getCoinComments","getProfile","getProfileCoins","getProfileBalances","postCreateContent","parseEventLogs","coinABI"],"mappings":"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;AACA;AoBr8BpB;AACP,EAAA;AACb,IAAA;AACJ,IAAA;AACA,MAAA;AAClB,IAAA;AACF,EAAA;AAMqB,EAAA;AAIZ,IAAA;AAEO,MAAA;AACd,IAAA;AAEmD,IAAA;AAET,IAAA;AACnB,MAAA;AACtB,IAAA;AAC+B,IAAA;AACX,IAAA;AAC0B,MAAA;AAC/C,IAAA;AAEY,IAAA;AACd,EAAA;AAEgD,EAAA;AACJ,IAAA;AACZ,IAAA;AACS,IAAA;AAEhB,IAAA;AACrB,MAAA;AACA,MAAA;AACU,QAAA;AACC,QAAA;AAC2B,UAAA;AAC1B,UAAA;AACV,QAAA;AACM,QAAA;AACR,MAAA;AACF,IAAA;AAEkB,IAAA;AACmB,MAAA;AACgB,MAAA;AACrD,IAAA;AAEkC,IAAA;AAM3B,IAAA;AACkB,MAAA;AACZ,MAAA;AACI,MAAA;AACjB,IAAA;AACF,EAAA;AACF;AAOY;AAC4B,EAAA;AACxC;ApB46BkE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/home/runner/work/zora-protocol-private/zora-protocol-private/packages/coins-sdk/dist/index.cjs","sourcesContent":[null,"import {\n  coinFactoryAddress,\n  coinFactoryABI as zoraFactoryImplABI,\n} from \"@zoralabs/protocol-deployments\";\nimport {\n  Address,\n  TransactionReceipt,\n  WalletClient,\n  ContractEventArgsFromTopics,\n  parseEventLogs,\n  Hex,\n  Account,\n  isAddressEqual,\n} from \"viem\";\nimport { base } from \"viem/chains\";\nimport { validateClientNetwork } from \"../utils/validateClientNetwork\";\nimport { GenericPublicClient } from \"../utils/genericPublicClient\";\nimport { validateMetadataURIContent } from \"../metadata\";\nimport { ValidMetadataURI } from \"../uploader/types\";\nimport { getChainFromId } from \"../utils/getChainFromId\";\nimport { postCreateContent } from \"../api\";\nimport { rethrowDecodedRevert } from \"../utils/rethrowDecodedRevert\";\n\nexport type CoinDeploymentLogArgs = ContractEventArgsFromTopics<\n  typeof zoraFactoryImplABI,\n  \"CoinCreatedV4\"\n>;\n\nconst STARTING_MARKET_CAPS = {\n  LOW: \"LOW\",\n  HIGH: \"HIGH\",\n} as const;\nexport type StartingMarketCap = keyof typeof STARTING_MARKET_CAPS;\n\nexport interface RawUriMetadata {\n  type: \"RAW_URI\";\n  uri: string;\n}\n\nconst CONTENT_COIN_CURRENCIES = {\n  CREATOR_COIN: \"CREATOR_COIN\",\n  ZORA: \"ZORA\",\n  ETH: \"ETH\",\n  CREATOR_COIN_OR_ZORA: \"CREATOR_COIN_OR_ZORA\",\n} as const;\nexport type ContentCoinCurrency = keyof typeof CONTENT_COIN_CURRENCIES;\n\nexport const CreateConstants = {\n  StartingMarketCaps: STARTING_MARKET_CAPS,\n  ContentCoinCurrencies: CONTENT_COIN_CURRENCIES,\n} as const;\n\nexport type CreateCoinArgs = {\n  creator: string;\n  name: string;\n  symbol: string;\n  metadata: RawUriMetadata;\n  currency: ContentCoinCurrency;\n  chainId?: number;\n  startingMarketCap?: StartingMarketCap;\n  platformReferrer?: string;\n  additionalOwners?: Address[];\n  payoutRecipientOverride?: Address;\n  skipMetadataValidation?: boolean;\n};\n\ntype TransactionParameters = {\n  to: Address;\n  data: Hex;\n  value: bigint;\n};\n\nexport async function createCoinCall({\n  creator,\n  name,\n  symbol,\n  metadata,\n  currency,\n  chainId = base.id,\n  payoutRecipientOverride,\n  additionalOwners,\n  platformReferrer,\n  skipMetadataValidation = false,\n}: CreateCoinArgs): Promise<TransactionParameters[]> {\n  // Validate metadata URI\n  if (!skipMetadataValidation) {\n    await validateMetadataURIContent(metadata.uri as ValidMetadataURI);\n  }\n\n  const createContentRequest = await postCreateContent({\n    currency,\n    chainId,\n    metadata,\n    creator,\n    name,\n    symbol,\n    platformReferrer,\n    additionalOwners,\n    payoutRecipientOverride,\n  });\n\n  if (!createContentRequest.data?.calls) {\n    throw new Error(\"Failed to create content calldata\");\n  }\n\n  return createContentRequest.data.calls.map((data) => ({\n    to: data.to as Address,\n    data: data.data as Hex,\n    value: BigInt(data.value),\n  }));\n}\n\n/**\n * Gets the deployed coin address from transaction receipt logs\n * @param receipt Transaction receipt containing the CoinCreated event\n * @returns The deployment information if found\n */\nexport function getCoinCreateFromLogs(\n  receipt: TransactionReceipt,\n): CoinDeploymentLogArgs | undefined {\n  const eventLogs = parseEventLogs({\n    abi: zoraFactoryImplABI,\n    logs: receipt.logs,\n  });\n\n  return eventLogs.find((log) => log.eventName === \"CoinCreatedV4\")?.args;\n}\n\n// Update createCoin to return both receipt and coin address\nexport async function createCoin({\n  call,\n  walletClient,\n  publicClient,\n  options,\n}: {\n  call: CreateCoinArgs;\n  walletClient: WalletClient;\n  publicClient: GenericPublicClient;\n  options?: {\n    gasMultiplier?: number;\n    account?: Account | Address;\n    skipValidateTransaction?: boolean;\n  };\n}) {\n  validateClientNetwork(publicClient);\n\n  const chainId = call.chainId ?? publicClient.chain.id;\n\n  const callRequest = await createCoinCall({\n    ...call,\n    chainId,\n  });\n\n  if (callRequest.length !== 1) {\n    throw new Error(\"Only one call is supported for this SDK version\");\n  }\n\n  const createContentCall = callRequest[0];\n\n  if (!createContentCall) {\n    throw new Error(\"Failed to load create content calldata from API\");\n  }\n\n  const coinFactoryAddressForChain =\n    coinFactoryAddress[call.chainId as keyof typeof coinFactoryAddress];\n\n  // Sanity check that the call is for the correct factory contract\n  if (!isAddressEqual(createContentCall.to, coinFactoryAddressForChain)) {\n    throw new Error(\"Creator coin is not supported for this SDK version\");\n  }\n\n  // Sanity check to ensure no buy orders are sent with there parameters\n  if (createContentCall.value !== 0n) {\n    throw new Error(\n      \"Creator coin and purchase is not supported for this SDK version.\",\n    );\n  }\n\n  // Prefer a LocalAccount from the wallet client when available to ensure\n  // offline signing (eth_sendRawTransaction) instead of wallet_sendTransaction\n  // which can error when a `from` field is present.\n  const selectedAccount =\n    (typeof options?.account === \"string\" ? undefined : options?.account) ??\n    walletClient.account;\n\n  if (!selectedAccount) {\n    throw new Error(\"Account is required\");\n  }\n\n  const viemCall = {\n    ...createContentCall,\n    account: selectedAccount,\n  };\n\n  // simulate call\n  if (!options?.skipValidateTransaction) {\n    try {\n      await publicClient.call(viemCall);\n    } catch (err) {\n      rethrowDecodedRevert(err, zoraFactoryImplABI);\n    }\n  }\n\n  const gasEstimate = options?.skipValidateTransaction\n    ? 10_000_000n\n    : await publicClient.estimateGas(viemCall);\n  const gasPrice = await publicClient.getGasPrice();\n\n  const hash = await (async () => {\n    try {\n      return await walletClient.sendTransaction({\n        ...viemCall,\n        gasPrice,\n        gas: gasEstimate,\n        chain: publicClient.chain,\n      });\n    } catch (err) {\n      rethrowDecodedRevert(err, zoraFactoryImplABI);\n    }\n  })();\n\n  const receipt = await publicClient.waitForTransactionReceipt({\n    hash,\n  });\n\n  const deployment = getCoinCreateFromLogs(receipt);\n\n  return {\n    hash,\n    receipt,\n    address: deployment?.coin,\n    deployment,\n    chain: getChainFromId(publicClient.chain.id),\n  };\n}\n","import { PublicClient } from \"viem\";\nimport { base, baseSepolia } from \"viem/chains\";\n\nexport const validateClientNetwork = (\n  publicClient: PublicClient<any, any, any, any>,\n) => {\n  const clientChainId = publicClient?.chain?.id;\n  if (clientChainId === base.id) {\n    return;\n  }\n  if (clientChainId === baseSepolia.id) {\n    return;\n  }\n\n  throw new Error(\n    \"Client network needs to be base or baseSepolia for current coin deployments.\",\n  );\n};\n","import { ValidMetadataURI } from \"../uploader/types\";\n\n/**\n * Clean the metadata URI to HTTPS format\n * @param metadataURI - The metadata URI to clean from IPFS or Arweave\n * @returns The cleaned metadata URI\n * @throws If the metadata URI is a data URI\n */\nexport function cleanAndValidateMetadataURI(uri: ValidMetadataURI) {\n  if (uri.startsWith(\"ipfs://\")) {\n    return uri.replace(\n      \"ipfs://\",\n      \"https://magic.decentralized-content.com/ipfs/\",\n    );\n  }\n  if (uri.startsWith(\"ar://\")) {\n    return uri.replace(\"ar://\", \"http://arweave.net/\");\n  }\n  if (uri.startsWith(\"data:\")) {\n    return uri;\n    // throw new Error(\"Data URIs are not supported\");\n  }\n  if (uri.startsWith(\"http://\") || uri.startsWith(\"https://\")) {\n    return uri;\n  }\n\n  throw new Error(\"Invalid metadata URI\");\n}\n","export type ValidMetadataJSON = {\n  name: string;\n  description: string;\n  image: string;\n  animation_url?: string;\n  content?: { uri: string; mime?: string };\n};\n\nfunction validateURIString(uri: unknown) {\n  if (typeof uri !== \"string\") {\n    throw new Error(\"URI must be a string\");\n  }\n  if (uri.startsWith(\"ipfs://\")) {\n    return true;\n  }\n  if (uri.startsWith(\"ar://\")) {\n    return true;\n  }\n  if (uri.startsWith(\"https://\")) {\n    return true;\n  }\n  if (uri.startsWith(\"data:\")) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Validate the metadata JSON object\n * @param metadata - The metadata object to validate\n */\nexport function validateMetadataJSON(metadata: ValidMetadataJSON | unknown) {\n  if (typeof metadata !== \"object\" || !metadata) {\n    throw new Error(\"Metadata must be an object and exist\");\n  }\n  if (typeof (metadata as { name: unknown }).name !== \"string\") {\n    throw new Error(\"Metadata name is required and must be a string\");\n  }\n  if (typeof (metadata as { description: unknown }).description !== \"string\") {\n    throw new Error(\"Metadata description is required and must be a string\");\n  }\n  if (typeof (metadata as { image: unknown }).image === \"string\") {\n    if (!validateURIString((metadata as { image: string }).image)) {\n      throw new Error(\"Metadata image is not a valid URI\");\n    }\n  } else {\n    throw new Error(\"Metadata image is required and must be a string\");\n  }\n  if (\"animation_url\" in metadata) {\n    if (\n      typeof (metadata as { animation_url?: unknown }).animation_url !==\n      \"string\"\n    ) {\n      throw new Error(\"Metadata animation_url, if provided, must be a string\");\n    }\n    if (!validateURIString(metadata.animation_url)) {\n      throw new Error(\"Metadata animation_url is not a valid URI\");\n    }\n  }\n  const content =\n    \"content\" in metadata && (metadata as { content?: unknown }).content;\n  if (content) {\n    if (typeof (content as { uri?: unknown }).uri !== \"string\") {\n      throw new Error(\"If provided, content.uri must be a string\");\n    }\n    if (!validateURIString((content as { uri: string }).uri)) {\n      throw new Error(\"If provided, content.uri must be a valid URI string\");\n    }\n    if (typeof (content as { mime?: unknown }).mime !== \"string\") {\n      throw new Error(\"If provided, content.mime must be a string\");\n    }\n  }\n\n  return true;\n}\n","import { cleanAndValidateMetadataURI } from \"./cleanAndValidateMetadataURI\";\nimport { ValidMetadataURI } from \"../uploader/types\";\nimport { validateMetadataJSON } from \"./validateMetadataJSON\";\n\n/**\n * Validate the metadata URI Content\n * @param metadataURI - The metadata URI to validate\n * @returns true if the metadata is valid, throws an error otherwise\n */\nexport async function validateMetadataURIContent(\n  metadataURI: ValidMetadataURI,\n) {\n  const cleanedURI = cleanAndValidateMetadataURI(metadataURI);\n  const response = await fetch(cleanedURI);\n  if (!response.ok) {\n    throw new Error(\"Metadata fetch failed\");\n  }\n  if (\n    ![\"application/json\", \"text/plain\"].includes(\n      response.headers.get(\"content-type\") ?? \"\",\n    )\n  ) {\n    throw new Error(\"Metadata is not a valid JSON or plain text response type\");\n  }\n  const metadataJson = await response.json();\n  return validateMetadataJSON(metadataJson);\n}\n","import { base, baseSepolia, Chain } from \"viem/chains\";\n\nexport function getChainFromId(chainId: number): Chain {\n  if (chainId === base.id) {\n    return base;\n  }\n  if (chainId === baseSepolia.id) {\n    return baseSepolia;\n  }\n\n  throw new Error(`Chain ID ${chainId} not supported`);\n}\n","// This file is auto-generated by @hey-api/openapi-ts\n\nimport type { ClientOptions } from \"./types.gen\";\nimport {\n  type Config,\n  type ClientOptions as DefaultClientOptions,\n  createClient,\n  createConfig,\n} from \"@hey-api/client-fetch\";\n\n/**\n * The `createClientConfig()` function will be called on client initialization\n * and the returned object will become the client's initial configuration.\n *\n * You may want to initialize your client this way instead of calling\n * `setConfig()`. This is useful for example if you're using Next.js\n * to ensure your client always has the correct values.\n */\nexport type CreateClientConfig<T extends DefaultClientOptions = ClientOptions> =\n  (\n    override?: Config<DefaultClientOptions & T>,\n  ) => Config<Required<DefaultClientOptions> & T>;\n\nexport const client = createClient(\n  createConfig<ClientOptions>({\n    baseUrl: \"https://api-sdk.zora.engineering/\",\n  }),\n);\n","// This file is auto-generated by @hey-api/openapi-ts\n\nimport type {\n  Options as ClientOptions,\n  TDataShape,\n  Client,\n} from \"@hey-api/client-fetch\";\nimport type {\n  GetApiKeyData,\n  GetApiKeyResponse,\n  GetCoinData,\n  GetCoinResponse,\n  GetCoinCommentsData,\n  GetCoinCommentsResponse,\n  GetCoinHoldersData,\n  GetCoinHoldersResponse,\n  GetCoinSwapsData,\n  GetCoinSwapsResponse,\n  GetCoinsData,\n  GetCoinsResponse,\n  SetCreateUploadJwtData,\n  SetCreateUploadJwtResponse,\n  GetExploreData,\n  GetExploreResponse,\n  GetProfileData,\n  GetProfileResponse,\n  GetProfileBalancesData,\n  GetProfileBalancesResponse,\n  GetProfileCoinsData,\n  GetProfileCoinsResponse,\n  PostQuoteData,\n  PostQuoteResponse,\n  PostQuoteError,\n  GetCreateContentPoolConfigData,\n  GetCreateContentPoolConfigResponse,\n  GetCreateContentPoolConfigError,\n  PostCreateContentData,\n  PostCreateContentResponse,\n  PostCreateContentError,\n} from \"./types.gen\";\nimport { client as _heyApiClient } from \"./client.gen\";\n\nexport type Options<\n  TData extends TDataShape = TDataShape,\n  ThrowOnError extends boolean = boolean,\n> = ClientOptions<TData, ThrowOnError> & {\n  /**\n   * You can provide a client instance returned by `createClient()` instead of\n   * individual options. This might be also useful if you want to implement a\n   * custom client.\n   */\n  client?: Client;\n  /**\n   * You can pass arbitrary values through the `meta` object. This can be\n   * used to access values that aren't defined as part of the SDK function.\n   */\n  meta?: Record<string, unknown>;\n};\n\n/**\n * zoraSDK_apiKey query\n */\nexport const getApiKey = <ThrowOnError extends boolean = false>(\n  options: Options<GetApiKeyData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetApiKeyResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/apiKey\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_coin query\n */\nexport const getCoin = <ThrowOnError extends boolean = false>(\n  options: Options<GetCoinData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetCoinResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/coin\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_coinComments query\n */\nexport const getCoinComments = <ThrowOnError extends boolean = false>(\n  options: Options<GetCoinCommentsData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetCoinCommentsResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/coinComments\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_coinHolders query\n */\nexport const getCoinHolders = <ThrowOnError extends boolean = false>(\n  options: Options<GetCoinHoldersData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetCoinHoldersResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/coinHolders\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_coinSwaps query\n */\nexport const getCoinSwaps = <ThrowOnError extends boolean = false>(\n  options: Options<GetCoinSwapsData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetCoinSwapsResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/coinSwaps\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_coins query\n */\nexport const getCoins = <ThrowOnError extends boolean = false>(\n  options: Options<GetCoinsData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetCoinsResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/coins\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_createUploadJWT mutation\n */\nexport const setCreateUploadJwt = <ThrowOnError extends boolean = false>(\n  options?: Options<SetCreateUploadJwtData, ThrowOnError>,\n) => {\n  return (options?.client ?? _heyApiClient).post<\n    SetCreateUploadJwtResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/createUploadJWT\",\n    ...options,\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...options?.headers,\n    },\n  });\n};\n\n/**\n * zoraSDK_explore query\n */\nexport const getExplore = <ThrowOnError extends boolean = false>(\n  options: Options<GetExploreData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetExploreResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/explore\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_profile query\n */\nexport const getProfile = <ThrowOnError extends boolean = false>(\n  options: Options<GetProfileData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetProfileResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/profile\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_profileBalances query\n */\nexport const getProfileBalances = <ThrowOnError extends boolean = false>(\n  options: Options<GetProfileBalancesData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetProfileBalancesResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/profileBalances\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_profileCoins query\n */\nexport const getProfileCoins = <ThrowOnError extends boolean = false>(\n  options: Options<GetProfileCoinsData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetProfileCoinsResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/profileCoins\",\n    ...options,\n  });\n};\n\nexport const postQuote = <ThrowOnError extends boolean = false>(\n  options?: Options<PostQuoteData, ThrowOnError>,\n) => {\n  return (options?.client ?? _heyApiClient).post<\n    PostQuoteResponse,\n    PostQuoteError,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/quote\",\n    ...options,\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...options?.headers,\n    },\n  });\n};\n\nexport const getCreateContentPoolConfig = <\n  ThrowOnError extends boolean = false,\n>(\n  options?: Options<GetCreateContentPoolConfigData, ThrowOnError>,\n) => {\n  return (options?.client ?? _heyApiClient).get<\n    GetCreateContentPoolConfigResponse,\n    GetCreateContentPoolConfigError,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/create/content/pool-config\",\n    ...options,\n  });\n};\n\nexport const postCreateContent = <ThrowOnError extends boolean = false>(\n  options?: Options<PostCreateContentData, ThrowOnError>,\n) => {\n  return (options?.client ?? _heyApiClient).post<\n    PostCreateContentResponse,\n    PostCreateContentError,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/create/content\",\n    ...options,\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...options?.headers,\n    },\n  });\n};\n","let apiKey: string | undefined;\nexport function setApiKey(key: string | undefined) {\n  apiKey = key;\n}\n\nexport function getApiKey() {\n  return apiKey;\n}\n\nexport function getApiKeyMeta() {\n  if (!apiKey) {\n    return {};\n  }\n  return {\n    headers: {\n      \"api-key\": apiKey,\n    },\n  };\n}\n","import { getExplore as getExploreSDK } from \"../client/sdk.gen\";\nimport type { GetExploreData, GetExploreResponse } from \"../client/types.gen\";\nimport { getApiKeyMeta } from \"./api-key\";\nimport { RequestOptionsType } from \"./query-types\";\n\n/**\n * The inner type for the explore queries that omits listType.\n * This is used to create the query object for the explore queries.\n */\nexport type QueryRequestType = Omit<GetExploreData[\"query\"], \"listType\">;\n\ntype ExploreResponse = { data?: GetExploreResponse };\n\nexport type ListType = GetExploreData[\"query\"][\"listType\"];\n\nexport type { ExploreResponse };\n\nexport type { GetExploreData };\n\n/**\n * Creates an explore query with the specified list type\n */\nconst createExploreQuery = (\n  query: QueryRequestType,\n  listType: ListType,\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> =>\n  getExploreSDK({\n    ...options,\n    query: { ...query, listType },\n    ...getApiKeyMeta(),\n  });\n\n/** Get top gaining coins */\nexport const getCoinsTopGainers = (\n  query: QueryRequestType = {},\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> =>\n  createExploreQuery(query, \"TOP_GAINERS\", options);\n\n/** Get coins with highest 24h volume */\nexport const getCoinsTopVolume24h = (\n  query: QueryRequestType = {},\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> =>\n  createExploreQuery(query, \"TOP_VOLUME_24H\", options);\n\n/** Get most valuable coins */\nexport const getCoinsMostValuable = (\n  query: QueryRequestType = {},\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> =>\n  createExploreQuery(query, \"MOST_VALUABLE\", options);\n\n/** Get newly created coins */\nexport const getCoinsNew = (\n  query: QueryRequestType = {},\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> => createExploreQuery(query, \"NEW\", options);\n\n/** Get recently traded coins */\nexport const getCoinsLastTraded = (\n  query: QueryRequestType = {},\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> =>\n  createExploreQuery(query, \"LAST_TRADED\", options);\n\n/** Get recently traded unique coins */\nexport const getCoinsLastTradedUnique = (\n  query: QueryRequestType = {},\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> =>\n  createExploreQuery(query, \"LAST_TRADED_UNIQUE\", options);\n\nexport const getCreatorCoins = (\n  query: QueryRequestType = {},\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> =>\n  createExploreQuery(query, \"NEW_CREATORS\", options);\n\nexport const getMostValuableCreatorCoins = (\n  query: QueryRequestType = {},\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> =>\n  createExploreQuery(query, \"MOST_VALUABLE_CREATORS\", options);\n","import {\n  GetCoinCommentsData,\n  GetCoinCommentsResponse,\n  GetCoinData,\n  GetCoinHoldersData,\n  GetCoinHoldersResponse,\n  GetCoinResponse,\n  GetCoinsData,\n  GetCoinsResponse,\n  GetCoinSwapsData,\n  GetCoinSwapsResponse,\n  GetProfileBalancesData,\n  GetProfileBalancesResponse,\n  GetProfileCoinsData,\n  GetProfileCoinsResponse,\n  GetProfileData,\n  GetProfileResponse,\n} from \"../client/types.gen\";\nimport {\n  getCoin as getCoinSDK,\n  getCoins as getCoinsSDK,\n  getCoinComments as getCoinCommentsSDK,\n  getCoinHolders as getCoinHoldersSDK,\n  getCoinSwaps as getCoinSwapsSDK,\n  getProfile as getProfileSDK,\n  getProfileBalances as getProfileBalancesSDK,\n  getProfileCoins as getProfileCoinsSDK,\n} from \"../client/sdk.gen\";\nimport { getApiKeyMeta } from \"./api-key\";\nimport { RequestOptionsType } from \"./query-types\";\nimport { RequestResult } from \"@hey-api/client-fetch\";\n\nexport type { RequestResult };\n\ntype GetCoinQuery = GetCoinData[\"query\"];\nexport type { GetCoinQuery, GetCoinData };\nexport type { GetCoinResponse } from \"../client/types.gen\";\n\nexport type CoinData = NonNullable<GetCoinResponse[\"zora20Token\"]>;\n\nexport const getCoin = async (\n  query: GetCoinQuery,\n  options?: RequestOptionsType<GetCoinData>,\n): Promise<RequestResult<GetCoinResponse>> => {\n  return await getCoinSDK({\n    ...options,\n    query,\n    ...getApiKeyMeta(),\n  });\n};\n\ntype GetCoinsQuery = GetCoinsData[\"query\"];\nexport type { GetCoinsQuery, GetCoinsData };\nexport type { GetCoinsResponse } from \"../client/types.gen\";\n\nexport const getCoins = async (\n  query: GetCoinsQuery,\n  options?: RequestOptionsType<GetCoinsData>,\n): Promise<RequestResult<GetCoinsResponse>> => {\n  return await getCoinsSDK({\n    query: {\n      coins: query.coins.map((coinData) => JSON.stringify(coinData)) as any,\n    },\n    ...getApiKeyMeta(),\n    ...options,\n  });\n};\n\ntype GetCoinHoldersQuery = GetCoinHoldersData[\"query\"];\nexport type { GetCoinHoldersQuery, GetCoinHoldersData };\nexport type { GetCoinHoldersResponse } from \"../client/types.gen\";\n\nexport const getCoinHolders = async (\n  query: GetCoinHoldersQuery,\n  options?: RequestOptionsType<GetCoinHoldersData>,\n): Promise<RequestResult<GetCoinHoldersResponse>> => {\n  return await getCoinHoldersSDK({\n    query,\n    ...getApiKeyMeta(),\n    ...options,\n  });\n};\n\ntype GetCoinSwapsQuery = GetCoinSwapsData[\"query\"];\nexport type { GetCoinSwapsQuery, GetCoinSwapsData };\nexport type { GetCoinSwapsResponse } from \"../client/types.gen\";\n\nexport const getCoinSwaps = async (\n  query: GetCoinSwapsQuery,\n  options?: RequestOptionsType<GetCoinSwapsData>,\n): Promise<RequestResult<GetCoinSwapsResponse>> => {\n  return await getCoinSwapsSDK({\n    query,\n    ...getApiKeyMeta(),\n    ...options,\n  });\n};\n\ntype GetCoinCommentsQuery = GetCoinCommentsData[\"query\"];\nexport type { GetCoinCommentsQuery, GetCoinCommentsData };\nexport type { GetCoinCommentsResponse } from \"../client/types.gen\";\n\nexport const getCoinComments = async (\n  query: GetCoinCommentsQuery,\n  options?: RequestOptionsType<GetCoinCommentsData>,\n): Promise<RequestResult<GetCoinCommentsResponse>> => {\n  return await getCoinCommentsSDK({\n    query,\n    ...getApiKeyMeta(),\n    ...options,\n  });\n};\n\ntype GetProfileQuery = GetProfileData[\"query\"];\nexport type { GetProfileQuery, GetProfileData };\nexport type { GetProfileResponse } from \"../client/types.gen\";\n\nexport const getProfile = async (\n  query: GetProfileQuery,\n  options?: RequestOptionsType<GetProfileData>,\n): Promise<RequestResult<GetProfileResponse>> => {\n  return await getProfileSDK({\n    query,\n    ...getApiKeyMeta(),\n    ...options,\n  });\n};\n\ntype GetProfileCoinsQuery = GetProfileCoinsData[\"query\"];\nexport type { GetProfileCoinsQuery, GetProfileCoinsData };\nexport type { GetProfileCoinsResponse } from \"../client/types.gen\";\n\nexport const getProfileCoins = async (\n  query: GetProfileCoinsQuery,\n  options?: RequestOptionsType<GetProfileCoinsData>,\n): Promise<RequestResult<GetProfileCoinsResponse>> => {\n  return await getProfileCoinsSDK({\n    query,\n    ...getApiKeyMeta(),\n    ...options,\n  });\n};\n\ntype GetProfileBalancesQuery = GetProfileBalancesData[\"query\"];\nexport type { GetProfileBalancesQuery, GetProfileBalancesData };\nexport type { GetProfileBalancesResponse } from \"../client/types.gen\";\n\nexport const getProfileBalances = async (\n  query: GetProfileBalancesQuery,\n  options?: RequestOptionsType<GetProfileBalancesData>,\n): Promise<RequestResult<GetProfileBalancesResponse>> => {\n  return await getProfileBalancesSDK({\n    query,\n    ...getApiKeyMeta(),\n    ...options,\n  });\n};\n","import {\n  PostCreateContentData,\n  PostCreateContentResponse,\n} from \"../client/types.gen\";\nimport { postCreateContent as postCreateContentSDK } from \"../client/sdk.gen\";\nimport { getApiKeyMeta } from \"./api-key\";\nimport { RequestOptionsType } from \"./query-types\";\nimport { RequestResult } from \"@hey-api/client-fetch\";\n\ntype PostCreateContentQuery = PostCreateContentData[\"body\"];\nexport type { PostCreateContentQuery, PostCreateContentResponse };\n\nexport type CoinCreateData = NonNullable<PostCreateContentResponse>;\n\nexport const postCreateContent = async (\n  body: PostCreateContentQuery,\n  options?: RequestOptionsType<PostCreateContentData>,\n): Promise<RequestResult<PostCreateContentResponse>> => {\n  return await postCreateContentSDK({\n    ...options,\n    body,\n    ...getApiKeyMeta(),\n  });\n};\n","import {\n  Abi,\n  BaseError,\n  ContractFunctionRevertedError,\n  decodeErrorResult,\n  Hex,\n} from \"viem\";\n\nexport function rethrowDecodedRevert(err: unknown, abi: Abi): never {\n  if (err instanceof BaseError) {\n    const revertError = err.walk(\n      (e) => e instanceof ContractFunctionRevertedError,\n    );\n    if (revertError instanceof ContractFunctionRevertedError) {\n      // Try to decode using factory ABI\n      try {\n        const revertData =\n          typeof (revertError as any).data === \"object\" &&\n          (revertError as any).data !== null &&\n          \"data\" in (revertError as any).data\n            ? (revertError as any).data.data\n            : (revertError as any).data;\n        const decoded = decodeErrorResult({\n          abi,\n          data: revertData as Hex,\n        });\n        const name = decoded.errorName;\n        const args = decoded.args as ReadonlyArray<unknown> | undefined;\n        const message =\n          Array.isArray(args) && args.length > 0\n            ? `${name}(${args.map((a) => String(a)).join(\", \")})`\n            : name;\n        throw new Error(`Create coin transaction reverted: ${message}`);\n      } catch {\n        const errorName = (revertError as any).data?.errorName as\n          | string\n          | undefined;\n        if (errorName) {\n          const args = (revertError as any).data?.args as unknown[] | undefined;\n          const message =\n            Array.isArray(args) && args.length > 0\n              ? `${errorName}(${args.map((a) => String(a)).join(\", \")})`\n              : errorName;\n          throw new Error(`Create coin transaction reverted: ${message}`);\n        }\n      }\n    }\n  }\n  throw err;\n}\n","import { coinABI } from \"@zoralabs/protocol-deployments\";\nimport { validateClientNetwork } from \"../utils/validateClientNetwork\";\nimport {\n  Account,\n  Address,\n  parseEventLogs,\n  SimulateContractParameters,\n  WalletClient,\n} from \"viem\";\nimport { GenericPublicClient } from \"../utils/genericPublicClient\";\nimport { getAttribution } from \"../utils/attribution\";\n\nexport type UpdateCoinURIArgs = {\n  coin: Address;\n  newURI: string;\n};\n\nexport function updateCoinURICall({\n  newURI,\n  coin,\n}: UpdateCoinURIArgs): SimulateContractParameters {\n  if (!newURI.startsWith(\"ipfs://\")) {\n    throw new Error(\"URI needs to be an ipfs:// prefix uri\");\n  }\n\n  return {\n    abi: coinABI,\n    address: coin,\n    functionName: \"setContractURI\",\n    args: [newURI],\n    dataSuffix: getAttribution(),\n  };\n}\n\nexport async function updateCoinURI(\n  args: UpdateCoinURIArgs,\n  walletClient: WalletClient,\n  publicClient: GenericPublicClient,\n  account?: Account | Address,\n) {\n  validateClientNetwork(publicClient);\n  const call = updateCoinURICall(args);\n  const { request } = await publicClient.simulateContract({\n    ...call,\n    account: account ?? walletClient.account,\n  });\n  const hash = await walletClient.writeContract(request);\n  const receipt = await publicClient.waitForTransactionReceipt({ hash });\n  const eventLogs = parseEventLogs({ abi: coinABI, logs: receipt.logs });\n  const uriUpdated = eventLogs.find(\n    (log) => log.eventName === \"ContractURIUpdated\",\n  );\n\n  return { hash, receipt, uriUpdated };\n}\n","import { Hex, keccak256, slice, toHex } from \"viem\";\n\nexport function getAttribution(): Hex {\n  const hash = keccak256(toHex(\"api-sdk.zora.engineering\"));\n  return slice(hash, 0, 4) as Hex;\n}\n","import { coinABI } from \"@zoralabs/protocol-deployments\";\nimport { validateClientNetwork } from \"../utils/validateClientNetwork\";\nimport {\n  Account,\n  Address,\n  parseEventLogs,\n  SimulateContractParameters,\n  WalletClient,\n} from \"viem\";\nimport { GenericPublicClient } from \"../utils/genericPublicClient\";\nimport { getAttribution } from \"../utils/attribution\";\n\nexport type UpdatePayoutRecipientArgs = {\n  coin: Address;\n  newPayoutRecipient: string;\n};\n\nexport function updatePayoutRecipientCall({\n  newPayoutRecipient,\n  coin,\n}: UpdatePayoutRecipientArgs): SimulateContractParameters {\n  return {\n    abi: coinABI,\n    address: coin,\n    functionName: \"setPayoutRecipient\",\n    args: [newPayoutRecipient],\n    dataSuffix: getAttribution(),\n  };\n}\n\nexport async function updatePayoutRecipient(\n  args: UpdatePayoutRecipientArgs,\n  walletClient: WalletClient,\n  publicClient: GenericPublicClient,\n  account?: Account | Address,\n) {\n  validateClientNetwork(publicClient);\n  const call = updatePayoutRecipientCall(args);\n  const { request } = await publicClient.simulateContract({\n    ...call,\n    account: account ?? walletClient.account!,\n  });\n  const hash = await walletClient.writeContract(request);\n  const receipt = await publicClient.waitForTransactionReceipt({ hash });\n  const eventLogs = parseEventLogs({ abi: coinABI, logs: receipt.logs });\n  const payoutRecipientUpdated = eventLogs.find(\n    (log) => log.eventName === \"CoinPayoutRecipientUpdated\",\n  );\n\n  return { hash, receipt, payoutRecipientUpdated };\n}\n","import { permit2ABI, permit2Address } from \"@zoralabs/protocol-deployments\";\nimport {\n  Account,\n  Address,\n  erc20Abi,\n  WalletClient,\n  maxUint256,\n  Hex,\n} from \"viem\";\nimport { base } from \"viem/chains\";\nimport { postQuote, PostQuoteResponse } from \"../client\";\nimport { GenericPublicClient } from \"../utils/genericPublicClient\";\n\ntype TradeERC20 = {\n  type: \"erc20\";\n  address: Address;\n};\n\ntype TradeETH = {\n  type: \"eth\";\n};\n\ntype PermitDetails = {\n  token: Address;\n  amount: bigint;\n  expiration: number;\n  nonce: number;\n};\n\ntype Permit = {\n  details: PermitDetails;\n  spender: Address;\n  sigDeadline: bigint;\n};\n\ntype PermitDetailsStringAmounts = {\n  token: Address;\n  amount: string;\n  expiration: number;\n  nonce: number;\n};\n\ntype PermitStringAmounts = {\n  details: PermitDetailsStringAmounts;\n  spender: Address;\n  sigDeadline: string;\n};\n\ntype SignatureWithPermit<TPermit = Permit> = {\n  signature: Hex;\n  permit: TPermit;\n};\n\nfunction convertBigIntToString(permit: Permit): PermitStringAmounts {\n  return {\n    ...permit,\n    details: {\n      ...permit.details,\n      amount: `${permit.details.amount}`,\n    },\n    sigDeadline: `${permit.sigDeadline}`,\n  };\n}\n\nconst PERMIT_SINGLE_TYPES = {\n  PermitSingle: [\n    { name: \"details\", type: \"PermitDetails\" },\n    { name: \"spender\", type: \"address\" },\n    { name: \"sigDeadline\", type: \"uint256\" },\n  ],\n  PermitDetails: [\n    { name: \"token\", type: \"address\" },\n    { name: \"amount\", type: \"uint160\" },\n    { name: \"expiration\", type: \"uint48\" },\n    { name: \"nonce\", type: \"uint48\" },\n  ],\n};\n\ntype TradeCurrency = TradeERC20 | TradeETH;\n\nexport type TradeParameters = {\n  sell: TradeCurrency;\n  buy: TradeCurrency;\n  amountIn: bigint;\n  slippage?: number;\n  // can be smart wallet or EOA here.\n  sender: Address;\n  // needs to be EOA, if signer is blank assumes EOA in sender.\n  signer?: Address;\n  recipient?: Address;\n  signatures?: SignatureWithPermit<PermitStringAmounts>[];\n  permitActiveSeconds?: number;\n};\n\nexport async function tradeCoin({\n  tradeParameters,\n  walletClient,\n  account,\n  publicClient,\n  validateTransaction = true,\n}: {\n  tradeParameters: TradeParameters;\n  walletClient: WalletClient;\n  account?: Account | Address;\n  publicClient: GenericPublicClient;\n  validateTransaction?: boolean;\n}) {\n  const quote = await createTradeCall(tradeParameters);\n\n  if (!account) {\n    account = walletClient.account;\n  }\n  if (!account) {\n    throw new Error(\"Account is required\");\n  }\n\n  // Set default recipient to wallet sender address if not provided\n  if (!tradeParameters.recipient) {\n    tradeParameters.recipient =\n      typeof account === \"string\" ? account : account.address;\n  }\n\n  // todo replace any\n  const signatures: { signature: Hex; permit: any }[] = [];\n  if (quote.permits) {\n    for (const permit of quote.permits) {\n      // return values: amount, expiration, nonce\n      const [, , nonce] = await publicClient.readContract({\n        abi: permit2ABI,\n        address: permit2Address[base.id],\n        functionName: \"allowance\",\n        args: [\n          typeof account === \"string\" ? account : account.address,\n          permit.permit.details.token as Address,\n          permit.permit.spender as Address,\n        ],\n      });\n      const permitToken = permit.permit.details.token as Address;\n      const allowance = await publicClient.readContract({\n        abi: erc20Abi,\n        address: permitToken,\n        functionName: \"allowance\",\n        args: [\n          typeof account === \"string\" ? account : account.address,\n          permit2Address[base.id],\n        ],\n      });\n      if (allowance < BigInt(permit.permit.details.amount)) {\n        const approvalTx = await walletClient.writeContract({\n          abi: erc20Abi,\n          address: permitToken,\n          functionName: \"approve\",\n          chain: base,\n          args: [permit2Address[base.id], maxUint256],\n          account,\n        });\n        await publicClient.waitForTransactionReceipt({\n          hash: approvalTx,\n        });\n      }\n      const message = {\n        details: {\n          token: permit.permit.details.token as Address,\n          amount: BigInt(permit.permit.details.amount!),\n          expiration: Number(permit.permit.details.expiration!),\n          nonce: nonce,\n        },\n        spender: permit.permit.spender as Address,\n        sigDeadline: BigInt(permit.permit.sigDeadline!),\n      };\n      const signature = await walletClient.signTypedData({\n        domain: {\n          name: \"Permit2\",\n          chainId: base.id,\n          verifyingContract: permit2Address[base.id],\n        },\n        primaryType: \"PermitSingle\",\n        types: PERMIT_SINGLE_TYPES,\n        message,\n        account,\n      });\n      signatures.push({\n        signature,\n        permit: convertBigIntToString(message),\n      });\n    }\n  }\n\n  const newQuote = await createTradeCall({\n    ...tradeParameters,\n    signatures,\n  });\n\n  const call = {\n    to: newQuote.call.target as Address,\n    data: newQuote.call.data as Hex,\n    value: BigInt(newQuote.call.value),\n    chain: base,\n    account,\n  };\n\n  // simulate call\n  if (validateTransaction) {\n    await publicClient.call(call);\n  }\n\n  const gasEstimate = validateTransaction\n    ? await publicClient.estimateGas(call)\n    : 10_000_000n;\n  const gasPrice = await publicClient.getGasPrice();\n\n  const tx = await walletClient.sendTransaction({\n    ...call,\n    gasPrice,\n    gas: gasEstimate,\n  });\n\n  const receipt = await publicClient.waitForTransactionReceipt({\n    hash: tx,\n  });\n\n  return receipt;\n}\n\nexport async function createTradeCall(\n  tradeParameters: TradeParameters,\n): Promise<PostQuoteResponse> {\n  if (tradeParameters.slippage && tradeParameters.slippage > 1) {\n    throw new Error(\"Slippage must be less than 1, max 0.99\");\n  }\n  if (tradeParameters.amountIn === BigInt(0)) {\n    throw new Error(\"Amount in must be greater than 0\");\n  }\n\n  const quote = await postQuote({\n    body: {\n      tokenIn: tradeParameters.sell,\n      tokenOut: tradeParameters.buy,\n      amountIn: tradeParameters.amountIn.toString(),\n      slippage: tradeParameters.slippage,\n      chainId: base.id,\n      sender: tradeParameters.sender,\n      recipient: tradeParameters.recipient || tradeParameters.sender,\n      signatures: tradeParameters.signatures,\n    },\n  });\n\n  if (!quote.data) {\n    console.error(quote);\n    throw new Error(\"Quote failed\");\n  }\n\n  return quote.data;\n}\n","import {\n  CreateMetadataParameters,\n  Uploader,\n  UploadResult,\n  ValidMetadataURI,\n} from \"./types\";\n\ntype Metadata = {\n  name: string;\n  symbol: string;\n  description: string;\n  image: string;\n  properties?: Record<string, string>;\n  animation_url?: string;\n  content?: {\n    uri: string;\n    mime: string | undefined;\n  };\n};\n\nexport function validateImageMimeType(mimeType: string) {\n  if (\n    ![\n      \"image/png\",\n      \"image/jpeg\",\n      \"image/jpg\",\n      \"image/gif\",\n      \"image/svg+xml\",\n    ].includes(mimeType)\n  ) {\n    throw new Error(\"Image must be a PNG, JPEG, JPG, GIF or SVG\");\n  }\n}\n\nexport function getURLFromUploadResult(uploadResult: UploadResult) {\n  return new URL(uploadResult.url);\n}\n\nexport class CoinMetadataBuilder {\n  private name: string | undefined;\n  private description: string | undefined;\n  private symbol: string | undefined;\n  private imageFile: File | undefined;\n  private imageURL: URL | undefined;\n  private mediaFile: File | undefined;\n  private mediaURL: URL | undefined;\n  private mediaMimeType: string | undefined;\n  private properties: Record<string, string> | undefined;\n\n  withName(name: string) {\n    this.name = name;\n    if (typeof name !== \"string\") {\n      throw new Error(\"Name must be a string\");\n    }\n\n    return this;\n  }\n\n  withSymbol(symbol: string) {\n    this.symbol = symbol;\n    if (typeof symbol !== \"string\") {\n      throw new Error(\"Symbol must be a string\");\n    }\n\n    return this;\n  }\n\n  withDescription(description: string) {\n    this.description = description;\n    if (typeof description !== \"string\") {\n      throw new Error(\"Description must be a string\");\n    }\n\n    return this;\n  }\n\n  withImage(image: File) {\n    if (this.imageURL) {\n      throw new Error(\"Image URL already set\");\n    }\n    if (!(image instanceof File)) {\n      throw new Error(\"Image must be a File\");\n    }\n    validateImageMimeType(image.type);\n    this.imageFile = image;\n\n    return this;\n  }\n\n  withImageURI(imageURI: string) {\n    if (this.imageFile) {\n      throw new Error(\"Image file already set\");\n    }\n    if (typeof imageURI !== \"string\") {\n      throw new Error(\"Image URI must be a string\");\n    }\n    const url = new URL(imageURI);\n    this.imageURL = url;\n\n    return this;\n  }\n\n  withProperties(properties: Record<string, string>) {\n    for (const [key, value] of Object.entries(properties)) {\n      if (typeof key !== \"string\") {\n        throw new Error(\"Property key must be a string\");\n      }\n      if (typeof value !== \"string\") {\n        throw new Error(\"Property value must be a string\");\n      }\n    }\n    if (!this.properties) {\n      this.properties = {};\n    }\n    this.properties = { ...this.properties, ...properties };\n\n    return this;\n  }\n\n  withMedia(media: File) {\n    if (this.mediaURL) {\n      throw new Error(\"Media URL already set\");\n    }\n    if (!(media instanceof File)) {\n      throw new Error(\"Media must be a File\");\n    }\n    this.mediaMimeType = media.type;\n    this.mediaFile = media;\n\n    return this;\n  }\n\n  withMediaURI(mediaURI: string, mediaMimeType: string | undefined) {\n    if (this.mediaFile) {\n      throw new Error(\"Media file already set\");\n    }\n    if (typeof mediaURI !== \"string\") {\n      throw new Error(\"Media URI must be a string\");\n    }\n    const url = new URL(mediaURI);\n    this.mediaURL = url;\n    this.mediaMimeType = mediaMimeType;\n\n    return this;\n  }\n\n  validate() {\n    if (!this.name) {\n      throw new Error(\"Name is required\");\n    }\n    if (!this.symbol) {\n      throw new Error(\"Symbol is required\");\n    }\n    if (!this.imageFile && !this.imageURL) {\n      throw new Error(\"Image is required\");\n    }\n\n    return this;\n  }\n\n  generateMetadata(): Metadata {\n    return {\n      name: this.name!,\n      symbol: this.symbol!,\n      description: this.description!,\n      image: this.imageURL!.toString(),\n      animation_url: this.mediaURL?.toString(),\n      content: this.mediaURL\n        ? {\n            uri: this.mediaURL?.toString(),\n            mime: this.mediaMimeType,\n          }\n        : undefined,\n      properties: this.properties,\n    };\n  }\n\n  async upload(uploader: Uploader): Promise<{\n    url: ValidMetadataURI;\n    createMetadataParameters: CreateMetadataParameters;\n    metadata: Metadata;\n  }> {\n    this.validate();\n\n    if (this.imageFile) {\n      const uploadResult = await uploader.upload(this.imageFile);\n      this.imageURL = getURLFromUploadResult(uploadResult);\n    }\n    if (this.mediaFile) {\n      const uploadResult = await uploader.upload(this.mediaFile);\n      this.mediaURL = getURLFromUploadResult(uploadResult);\n    }\n    const metadata = this.generateMetadata();\n    const uploadResult = await uploader.upload(\n      new File([JSON.stringify(metadata)], \"metadata.json\", {\n        type: \"application/json\",\n      }),\n    );\n\n    return {\n      url: getURLFromUploadResult(uploadResult).toString() as ValidMetadataURI,\n      createMetadataParameters: {\n        name: this.name!,\n        symbol: this.symbol!,\n        metadata: {\n          type: \"RAW_URI\",\n          uri: uploadResult.url,\n        },\n      },\n      metadata,\n    };\n  }\n}\n\nexport function createMetadataBuilder() {\n  return new CoinMetadataBuilder();\n}\n","import {\n  SetCreateUploadJwtData,\n  SetCreateUploadJwtResponse,\n} from \"../client/types.gen\";\nimport { setCreateUploadJwt as setCreateUploadJwtSDK } from \"../client/sdk.gen\";\nimport { getApiKeyMeta } from \"./api-key\";\nimport { RequestOptionsType } from \"./query-types\";\nimport { RequestResult } from \"@hey-api/client-fetch\";\n\ntype SetCreateUploadJwtQuery = SetCreateUploadJwtData[\"body\"];\nexport type { SetCreateUploadJwtQuery, SetCreateUploadJwtData };\nexport type { SetCreateUploadJwtResponse } from \"../client/types.gen\";\n\nexport const setCreateUploadJwt = async (\n  body: SetCreateUploadJwtQuery,\n  options?: RequestOptionsType<SetCreateUploadJwtData>,\n): Promise<RequestResult<SetCreateUploadJwtResponse>> => {\n  return await setCreateUploadJwtSDK({\n    body,\n    ...getApiKeyMeta(),\n    ...options,\n  });\n};\n","import { Address } from \"viem\";\nimport { Uploader, UploadResult } from \"../types\";\nimport { getApiKey } from \"../../api/api-key\";\nimport { setCreateUploadJwt } from \"../../api/internal\";\n\n/**\n * Zora IPFS uploader implementation\n */\nexport class ZoraUploader implements Uploader {\n  constructor(creatorAddress: Address) {\n    this.creatorAddress = creatorAddress;\n    if (!getApiKey()) {\n      throw new Error(\"API key is required for metadata interactions\");\n    }\n  }\n\n  private creatorAddress: Address;\n  private jwtApiKey: string | undefined;\n  private jwtApiKeyExpiresAt: number | undefined;\n\n  async getJWTApiKey() {\n    if (\n      this.jwtApiKey &&\n      this.jwtApiKeyExpiresAt &&\n      this.jwtApiKeyExpiresAt > Date.now()\n    ) {\n      return this.jwtApiKey;\n    }\n    // Expires in 1 hour\n    this.jwtApiKeyExpiresAt = Date.now() + 1000 * 60 * 60;\n\n    const response = await setCreateUploadJwt({\n      creatorAddress: this.creatorAddress,\n    });\n    this.jwtApiKey = response.data?.createUploadJwtFromApiKey;\n    if (!this.jwtApiKey) {\n      throw new Error(\"Failed to create upload JWT\");\n    }\n\n    return this.jwtApiKey;\n  }\n\n  async upload(file: File): Promise<UploadResult> {\n    const jwtApiKey = await this.getJWTApiKey();\n    const formData = new FormData();\n    formData.append(\"file\", file, file.name);\n\n    const response = await fetch(\n      \"https://ipfs-uploader.zora.co/api/v0/add?cid-version=1\",\n      {\n        method: \"POST\",\n        headers: {\n          Authorization: `Bearer ${jwtApiKey}`,\n          Accept: \"*/*\",\n        },\n        body: formData,\n      },\n    );\n\n    if (!response.ok) {\n      console.error(await response.text());\n      throw new Error(`Failed to upload file: ${response.statusText}`);\n    }\n\n    const data = (await response.json()) as {\n      cid: string;\n      size: number | undefined;\n      mimeType: string | undefined;\n    };\n\n    return {\n      url: `ipfs://${data.cid}`,\n      size: data.size,\n      mimeType: data.mimeType,\n    };\n  }\n}\n\n/**\n * Create a new Zora IPFS uploader\n */\nexport function createZoraUploaderForCreator(\n  creatorAddress: Address,\n): Uploader {\n  return new ZoraUploader(creatorAddress);\n}\n"]}