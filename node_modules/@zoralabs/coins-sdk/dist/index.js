// src/actions/createCoin.ts
import {
  coinFactoryAddress,
  coinFactoryABI as zoraFactoryImplABI
} from "@zoralabs/protocol-deployments";
import {
  parseEventLogs,
  isAddressEqual
} from "viem";
import { base as base3 } from "viem/chains";

// src/utils/validateClientNetwork.ts
import { base, baseSepolia } from "viem/chains";
var validateClientNetwork = (publicClient) => {
  const clientChainId = publicClient?.chain?.id;
  if (clientChainId === base.id) {
    return;
  }
  if (clientChainId === baseSepolia.id) {
    return;
  }
  throw new Error(
    "Client network needs to be base or baseSepolia for current coin deployments."
  );
};

// src/metadata/cleanAndValidateMetadataURI.ts
function cleanAndValidateMetadataURI(uri) {
  if (uri.startsWith("ipfs://")) {
    return uri.replace(
      "ipfs://",
      "https://magic.decentralized-content.com/ipfs/"
    );
  }
  if (uri.startsWith("ar://")) {
    return uri.replace("ar://", "http://arweave.net/");
  }
  if (uri.startsWith("data:")) {
    return uri;
  }
  if (uri.startsWith("http://") || uri.startsWith("https://")) {
    return uri;
  }
  throw new Error("Invalid metadata URI");
}

// src/metadata/validateMetadataJSON.ts
function validateURIString(uri) {
  if (typeof uri !== "string") {
    throw new Error("URI must be a string");
  }
  if (uri.startsWith("ipfs://")) {
    return true;
  }
  if (uri.startsWith("ar://")) {
    return true;
  }
  if (uri.startsWith("https://")) {
    return true;
  }
  if (uri.startsWith("data:")) {
    return true;
  }
  return false;
}
function validateMetadataJSON(metadata) {
  if (typeof metadata !== "object" || !metadata) {
    throw new Error("Metadata must be an object and exist");
  }
  if (typeof metadata.name !== "string") {
    throw new Error("Metadata name is required and must be a string");
  }
  if (typeof metadata.description !== "string") {
    throw new Error("Metadata description is required and must be a string");
  }
  if (typeof metadata.image === "string") {
    if (!validateURIString(metadata.image)) {
      throw new Error("Metadata image is not a valid URI");
    }
  } else {
    throw new Error("Metadata image is required and must be a string");
  }
  if ("animation_url" in metadata) {
    if (typeof metadata.animation_url !== "string") {
      throw new Error("Metadata animation_url, if provided, must be a string");
    }
    if (!validateURIString(metadata.animation_url)) {
      throw new Error("Metadata animation_url is not a valid URI");
    }
  }
  const content = "content" in metadata && metadata.content;
  if (content) {
    if (typeof content.uri !== "string") {
      throw new Error("If provided, content.uri must be a string");
    }
    if (!validateURIString(content.uri)) {
      throw new Error("If provided, content.uri must be a valid URI string");
    }
    if (typeof content.mime !== "string") {
      throw new Error("If provided, content.mime must be a string");
    }
  }
  return true;
}

// src/metadata/validateMetadataURIContent.ts
async function validateMetadataURIContent(metadataURI) {
  const cleanedURI = cleanAndValidateMetadataURI(metadataURI);
  const response = await fetch(cleanedURI);
  if (!response.ok) {
    throw new Error("Metadata fetch failed");
  }
  if (!["application/json", "text/plain"].includes(
    response.headers.get("content-type") ?? ""
  )) {
    throw new Error("Metadata is not a valid JSON or plain text response type");
  }
  const metadataJson = await response.json();
  return validateMetadataJSON(metadataJson);
}

// src/utils/getChainFromId.ts
import { base as base2, baseSepolia as baseSepolia2 } from "viem/chains";
function getChainFromId(chainId) {
  if (chainId === base2.id) {
    return base2;
  }
  if (chainId === baseSepolia2.id) {
    return baseSepolia2;
  }
  throw new Error(`Chain ID ${chainId} not supported`);
}

// src/client/client.gen.ts
import {
  createClient,
  createConfig
} from "@hey-api/client-fetch";
var client = createClient(
  createConfig({
    baseUrl: "https://api-sdk.zora.engineering/"
  })
);

// src/client/sdk.gen.ts
var getCoin = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/coin",
    ...options
  });
};
var getCoinComments = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/coinComments",
    ...options
  });
};
var getCoinHolders = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/coinHolders",
    ...options
  });
};
var getCoinSwaps = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/coinSwaps",
    ...options
  });
};
var getCoins = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/coins",
    ...options
  });
};
var setCreateUploadJwt = (options) => {
  return (options?.client ?? client).post({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/createUploadJWT",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers
    }
  });
};
var getExplore = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/explore",
    ...options
  });
};
var getProfile = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/profile",
    ...options
  });
};
var getProfileBalances = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/profileBalances",
    ...options
  });
};
var getProfileCoins = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/profileCoins",
    ...options
  });
};
var postQuote = (options) => {
  return (options?.client ?? client).post({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/quote",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers
    }
  });
};
var postCreateContent = (options) => {
  return (options?.client ?? client).post({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/create/content",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers
    }
  });
};

// src/api/api-key.ts
var apiKey;
function setApiKey(key) {
  apiKey = key;
}
function getApiKey() {
  return apiKey;
}
function getApiKeyMeta() {
  if (!apiKey) {
    return {};
  }
  return {
    headers: {
      "api-key": apiKey
    }
  };
}

// src/api/explore.ts
var createExploreQuery = (query, listType, options) => getExplore({
  ...options,
  query: { ...query, listType },
  ...getApiKeyMeta()
});
var getCoinsTopGainers = (query = {}, options) => createExploreQuery(query, "TOP_GAINERS", options);
var getCoinsTopVolume24h = (query = {}, options) => createExploreQuery(query, "TOP_VOLUME_24H", options);
var getCoinsMostValuable = (query = {}, options) => createExploreQuery(query, "MOST_VALUABLE", options);
var getCoinsNew = (query = {}, options) => createExploreQuery(query, "NEW", options);
var getCoinsLastTraded = (query = {}, options) => createExploreQuery(query, "LAST_TRADED", options);
var getCoinsLastTradedUnique = (query = {}, options) => createExploreQuery(query, "LAST_TRADED_UNIQUE", options);
var getCreatorCoins = (query = {}, options) => createExploreQuery(query, "NEW_CREATORS", options);
var getMostValuableCreatorCoins = (query = {}, options) => createExploreQuery(query, "MOST_VALUABLE_CREATORS", options);

// src/api/queries.ts
var getCoin2 = async (query, options) => {
  return await getCoin({
    ...options,
    query,
    ...getApiKeyMeta()
  });
};
var getCoins2 = async (query, options) => {
  return await getCoins({
    query: {
      coins: query.coins.map((coinData) => JSON.stringify(coinData))
    },
    ...getApiKeyMeta(),
    ...options
  });
};
var getCoinHolders2 = async (query, options) => {
  return await getCoinHolders({
    query,
    ...getApiKeyMeta(),
    ...options
  });
};
var getCoinSwaps2 = async (query, options) => {
  return await getCoinSwaps({
    query,
    ...getApiKeyMeta(),
    ...options
  });
};
var getCoinComments2 = async (query, options) => {
  return await getCoinComments({
    query,
    ...getApiKeyMeta(),
    ...options
  });
};
var getProfile2 = async (query, options) => {
  return await getProfile({
    query,
    ...getApiKeyMeta(),
    ...options
  });
};
var getProfileCoins2 = async (query, options) => {
  return await getProfileCoins({
    query,
    ...getApiKeyMeta(),
    ...options
  });
};
var getProfileBalances2 = async (query, options) => {
  return await getProfileBalances({
    query,
    ...getApiKeyMeta(),
    ...options
  });
};

// src/api/create.ts
var postCreateContent2 = async (body, options) => {
  return await postCreateContent({
    ...options,
    body,
    ...getApiKeyMeta()
  });
};

// src/utils/rethrowDecodedRevert.ts
import {
  BaseError,
  ContractFunctionRevertedError,
  decodeErrorResult
} from "viem";
function rethrowDecodedRevert(err, abi) {
  if (err instanceof BaseError) {
    const revertError = err.walk(
      (e) => e instanceof ContractFunctionRevertedError
    );
    if (revertError instanceof ContractFunctionRevertedError) {
      try {
        const revertData = typeof revertError.data === "object" && revertError.data !== null && "data" in revertError.data ? revertError.data.data : revertError.data;
        const decoded = decodeErrorResult({
          abi,
          data: revertData
        });
        const name = decoded.errorName;
        const args = decoded.args;
        const message = Array.isArray(args) && args.length > 0 ? `${name}(${args.map((a) => String(a)).join(", ")})` : name;
        throw new Error(`Create coin transaction reverted: ${message}`);
      } catch {
        const errorName = revertError.data?.errorName;
        if (errorName) {
          const args = revertError.data?.args;
          const message = Array.isArray(args) && args.length > 0 ? `${errorName}(${args.map((a) => String(a)).join(", ")})` : errorName;
          throw new Error(`Create coin transaction reverted: ${message}`);
        }
      }
    }
  }
  throw err;
}

// src/actions/createCoin.ts
var STARTING_MARKET_CAPS = {
  LOW: "LOW",
  HIGH: "HIGH"
};
var CONTENT_COIN_CURRENCIES = {
  CREATOR_COIN: "CREATOR_COIN",
  ZORA: "ZORA",
  ETH: "ETH",
  CREATOR_COIN_OR_ZORA: "CREATOR_COIN_OR_ZORA"
};
var CreateConstants = {
  StartingMarketCaps: STARTING_MARKET_CAPS,
  ContentCoinCurrencies: CONTENT_COIN_CURRENCIES
};
async function createCoinCall({
  creator,
  name,
  symbol,
  metadata,
  currency,
  chainId = base3.id,
  payoutRecipientOverride,
  additionalOwners,
  platformReferrer,
  skipMetadataValidation = false
}) {
  if (!skipMetadataValidation) {
    await validateMetadataURIContent(metadata.uri);
  }
  const createContentRequest = await postCreateContent2({
    currency,
    chainId,
    metadata,
    creator,
    name,
    symbol,
    platformReferrer,
    additionalOwners,
    payoutRecipientOverride
  });
  if (!createContentRequest.data?.calls) {
    throw new Error("Failed to create content calldata");
  }
  return createContentRequest.data.calls.map((data) => ({
    to: data.to,
    data: data.data,
    value: BigInt(data.value)
  }));
}
function getCoinCreateFromLogs(receipt) {
  const eventLogs = parseEventLogs({
    abi: zoraFactoryImplABI,
    logs: receipt.logs
  });
  return eventLogs.find((log) => log.eventName === "CoinCreatedV4")?.args;
}
async function createCoin({
  call,
  walletClient,
  publicClient,
  options
}) {
  validateClientNetwork(publicClient);
  const chainId = call.chainId ?? publicClient.chain.id;
  const callRequest = await createCoinCall({
    ...call,
    chainId
  });
  if (callRequest.length !== 1) {
    throw new Error("Only one call is supported for this SDK version");
  }
  const createContentCall = callRequest[0];
  if (!createContentCall) {
    throw new Error("Failed to load create content calldata from API");
  }
  const coinFactoryAddressForChain = coinFactoryAddress[call.chainId];
  if (!isAddressEqual(createContentCall.to, coinFactoryAddressForChain)) {
    throw new Error("Creator coin is not supported for this SDK version");
  }
  if (createContentCall.value !== 0n) {
    throw new Error(
      "Creator coin and purchase is not supported for this SDK version."
    );
  }
  const selectedAccount = (typeof options?.account === "string" ? void 0 : options?.account) ?? walletClient.account;
  if (!selectedAccount) {
    throw new Error("Account is required");
  }
  const viemCall = {
    ...createContentCall,
    account: selectedAccount
  };
  if (!options?.skipValidateTransaction) {
    try {
      await publicClient.call(viemCall);
    } catch (err) {
      rethrowDecodedRevert(err, zoraFactoryImplABI);
    }
  }
  const gasEstimate = options?.skipValidateTransaction ? 10000000n : await publicClient.estimateGas(viemCall);
  const gasPrice = await publicClient.getGasPrice();
  const hash = await (async () => {
    try {
      return await walletClient.sendTransaction({
        ...viemCall,
        gasPrice,
        gas: gasEstimate,
        chain: publicClient.chain
      });
    } catch (err) {
      rethrowDecodedRevert(err, zoraFactoryImplABI);
    }
  })();
  const receipt = await publicClient.waitForTransactionReceipt({
    hash
  });
  const deployment = getCoinCreateFromLogs(receipt);
  return {
    hash,
    receipt,
    address: deployment?.coin,
    deployment,
    chain: getChainFromId(publicClient.chain.id)
  };
}

// src/actions/updateCoinURI.ts
import { coinABI } from "@zoralabs/protocol-deployments";
import {
  parseEventLogs as parseEventLogs2
} from "viem";

// src/utils/attribution.ts
import { keccak256, slice, toHex } from "viem";
function getAttribution() {
  const hash = keccak256(toHex("api-sdk.zora.engineering"));
  return slice(hash, 0, 4);
}

// src/actions/updateCoinURI.ts
function updateCoinURICall({
  newURI,
  coin
}) {
  if (!newURI.startsWith("ipfs://")) {
    throw new Error("URI needs to be an ipfs:// prefix uri");
  }
  return {
    abi: coinABI,
    address: coin,
    functionName: "setContractURI",
    args: [newURI],
    dataSuffix: getAttribution()
  };
}
async function updateCoinURI(args, walletClient, publicClient, account) {
  validateClientNetwork(publicClient);
  const call = updateCoinURICall(args);
  const { request } = await publicClient.simulateContract({
    ...call,
    account: account ?? walletClient.account
  });
  const hash = await walletClient.writeContract(request);
  const receipt = await publicClient.waitForTransactionReceipt({ hash });
  const eventLogs = parseEventLogs2({ abi: coinABI, logs: receipt.logs });
  const uriUpdated = eventLogs.find(
    (log) => log.eventName === "ContractURIUpdated"
  );
  return { hash, receipt, uriUpdated };
}

// src/actions/updatePayoutRecipient.ts
import { coinABI as coinABI2 } from "@zoralabs/protocol-deployments";
import {
  parseEventLogs as parseEventLogs3
} from "viem";
function updatePayoutRecipientCall({
  newPayoutRecipient,
  coin
}) {
  return {
    abi: coinABI2,
    address: coin,
    functionName: "setPayoutRecipient",
    args: [newPayoutRecipient],
    dataSuffix: getAttribution()
  };
}
async function updatePayoutRecipient(args, walletClient, publicClient, account) {
  validateClientNetwork(publicClient);
  const call = updatePayoutRecipientCall(args);
  const { request } = await publicClient.simulateContract({
    ...call,
    account: account ?? walletClient.account
  });
  const hash = await walletClient.writeContract(request);
  const receipt = await publicClient.waitForTransactionReceipt({ hash });
  const eventLogs = parseEventLogs3({ abi: coinABI2, logs: receipt.logs });
  const payoutRecipientUpdated = eventLogs.find(
    (log) => log.eventName === "CoinPayoutRecipientUpdated"
  );
  return { hash, receipt, payoutRecipientUpdated };
}

// src/actions/tradeCoin.ts
import { permit2ABI, permit2Address } from "@zoralabs/protocol-deployments";
import {
  erc20Abi,
  maxUint256
} from "viem";
import { base as base4 } from "viem/chains";
function convertBigIntToString(permit) {
  return {
    ...permit,
    details: {
      ...permit.details,
      amount: `${permit.details.amount}`
    },
    sigDeadline: `${permit.sigDeadline}`
  };
}
var PERMIT_SINGLE_TYPES = {
  PermitSingle: [
    { name: "details", type: "PermitDetails" },
    { name: "spender", type: "address" },
    { name: "sigDeadline", type: "uint256" }
  ],
  PermitDetails: [
    { name: "token", type: "address" },
    { name: "amount", type: "uint160" },
    { name: "expiration", type: "uint48" },
    { name: "nonce", type: "uint48" }
  ]
};
async function tradeCoin({
  tradeParameters,
  walletClient,
  account,
  publicClient,
  validateTransaction = true
}) {
  const quote = await createTradeCall(tradeParameters);
  if (!account) {
    account = walletClient.account;
  }
  if (!account) {
    throw new Error("Account is required");
  }
  if (!tradeParameters.recipient) {
    tradeParameters.recipient = typeof account === "string" ? account : account.address;
  }
  const signatures = [];
  if (quote.permits) {
    for (const permit of quote.permits) {
      const [, , nonce] = await publicClient.readContract({
        abi: permit2ABI,
        address: permit2Address[base4.id],
        functionName: "allowance",
        args: [
          typeof account === "string" ? account : account.address,
          permit.permit.details.token,
          permit.permit.spender
        ]
      });
      const permitToken = permit.permit.details.token;
      const allowance = await publicClient.readContract({
        abi: erc20Abi,
        address: permitToken,
        functionName: "allowance",
        args: [
          typeof account === "string" ? account : account.address,
          permit2Address[base4.id]
        ]
      });
      if (allowance < BigInt(permit.permit.details.amount)) {
        const approvalTx = await walletClient.writeContract({
          abi: erc20Abi,
          address: permitToken,
          functionName: "approve",
          chain: base4,
          args: [permit2Address[base4.id], maxUint256],
          account
        });
        await publicClient.waitForTransactionReceipt({
          hash: approvalTx
        });
      }
      const message = {
        details: {
          token: permit.permit.details.token,
          amount: BigInt(permit.permit.details.amount),
          expiration: Number(permit.permit.details.expiration),
          nonce
        },
        spender: permit.permit.spender,
        sigDeadline: BigInt(permit.permit.sigDeadline)
      };
      const signature = await walletClient.signTypedData({
        domain: {
          name: "Permit2",
          chainId: base4.id,
          verifyingContract: permit2Address[base4.id]
        },
        primaryType: "PermitSingle",
        types: PERMIT_SINGLE_TYPES,
        message,
        account
      });
      signatures.push({
        signature,
        permit: convertBigIntToString(message)
      });
    }
  }
  const newQuote = await createTradeCall({
    ...tradeParameters,
    signatures
  });
  const call = {
    to: newQuote.call.target,
    data: newQuote.call.data,
    value: BigInt(newQuote.call.value),
    chain: base4,
    account
  };
  if (validateTransaction) {
    await publicClient.call(call);
  }
  const gasEstimate = validateTransaction ? await publicClient.estimateGas(call) : 10000000n;
  const gasPrice = await publicClient.getGasPrice();
  const tx = await walletClient.sendTransaction({
    ...call,
    gasPrice,
    gas: gasEstimate
  });
  const receipt = await publicClient.waitForTransactionReceipt({
    hash: tx
  });
  return receipt;
}
async function createTradeCall(tradeParameters) {
  if (tradeParameters.slippage && tradeParameters.slippage > 1) {
    throw new Error("Slippage must be less than 1, max 0.99");
  }
  if (tradeParameters.amountIn === BigInt(0)) {
    throw new Error("Amount in must be greater than 0");
  }
  const quote = await postQuote({
    body: {
      tokenIn: tradeParameters.sell,
      tokenOut: tradeParameters.buy,
      amountIn: tradeParameters.amountIn.toString(),
      slippage: tradeParameters.slippage,
      chainId: base4.id,
      sender: tradeParameters.sender,
      recipient: tradeParameters.recipient || tradeParameters.sender,
      signatures: tradeParameters.signatures
    }
  });
  if (!quote.data) {
    console.error(quote);
    throw new Error("Quote failed");
  }
  return quote.data;
}

// src/uploader/metadata.ts
function validateImageMimeType(mimeType) {
  if (![
    "image/png",
    "image/jpeg",
    "image/jpg",
    "image/gif",
    "image/svg+xml"
  ].includes(mimeType)) {
    throw new Error("Image must be a PNG, JPEG, JPG, GIF or SVG");
  }
}
function getURLFromUploadResult(uploadResult) {
  return new URL(uploadResult.url);
}
var CoinMetadataBuilder = class {
  withName(name) {
    this.name = name;
    if (typeof name !== "string") {
      throw new Error("Name must be a string");
    }
    return this;
  }
  withSymbol(symbol) {
    this.symbol = symbol;
    if (typeof symbol !== "string") {
      throw new Error("Symbol must be a string");
    }
    return this;
  }
  withDescription(description) {
    this.description = description;
    if (typeof description !== "string") {
      throw new Error("Description must be a string");
    }
    return this;
  }
  withImage(image) {
    if (this.imageURL) {
      throw new Error("Image URL already set");
    }
    if (!(image instanceof File)) {
      throw new Error("Image must be a File");
    }
    validateImageMimeType(image.type);
    this.imageFile = image;
    return this;
  }
  withImageURI(imageURI) {
    if (this.imageFile) {
      throw new Error("Image file already set");
    }
    if (typeof imageURI !== "string") {
      throw new Error("Image URI must be a string");
    }
    const url = new URL(imageURI);
    this.imageURL = url;
    return this;
  }
  withProperties(properties) {
    for (const [key, value] of Object.entries(properties)) {
      if (typeof key !== "string") {
        throw new Error("Property key must be a string");
      }
      if (typeof value !== "string") {
        throw new Error("Property value must be a string");
      }
    }
    if (!this.properties) {
      this.properties = {};
    }
    this.properties = { ...this.properties, ...properties };
    return this;
  }
  withMedia(media) {
    if (this.mediaURL) {
      throw new Error("Media URL already set");
    }
    if (!(media instanceof File)) {
      throw new Error("Media must be a File");
    }
    this.mediaMimeType = media.type;
    this.mediaFile = media;
    return this;
  }
  withMediaURI(mediaURI, mediaMimeType) {
    if (this.mediaFile) {
      throw new Error("Media file already set");
    }
    if (typeof mediaURI !== "string") {
      throw new Error("Media URI must be a string");
    }
    const url = new URL(mediaURI);
    this.mediaURL = url;
    this.mediaMimeType = mediaMimeType;
    return this;
  }
  validate() {
    if (!this.name) {
      throw new Error("Name is required");
    }
    if (!this.symbol) {
      throw new Error("Symbol is required");
    }
    if (!this.imageFile && !this.imageURL) {
      throw new Error("Image is required");
    }
    return this;
  }
  generateMetadata() {
    return {
      name: this.name,
      symbol: this.symbol,
      description: this.description,
      image: this.imageURL.toString(),
      animation_url: this.mediaURL?.toString(),
      content: this.mediaURL ? {
        uri: this.mediaURL?.toString(),
        mime: this.mediaMimeType
      } : void 0,
      properties: this.properties
    };
  }
  async upload(uploader) {
    this.validate();
    if (this.imageFile) {
      const uploadResult2 = await uploader.upload(this.imageFile);
      this.imageURL = getURLFromUploadResult(uploadResult2);
    }
    if (this.mediaFile) {
      const uploadResult2 = await uploader.upload(this.mediaFile);
      this.mediaURL = getURLFromUploadResult(uploadResult2);
    }
    const metadata = this.generateMetadata();
    const uploadResult = await uploader.upload(
      new File([JSON.stringify(metadata)], "metadata.json", {
        type: "application/json"
      })
    );
    return {
      url: getURLFromUploadResult(uploadResult).toString(),
      createMetadataParameters: {
        name: this.name,
        symbol: this.symbol,
        metadata: {
          type: "RAW_URI",
          uri: uploadResult.url
        }
      },
      metadata
    };
  }
};
function createMetadataBuilder() {
  return new CoinMetadataBuilder();
}

// src/api/internal.ts
var setCreateUploadJwt2 = async (body, options) => {
  return await setCreateUploadJwt({
    body,
    ...getApiKeyMeta(),
    ...options
  });
};

// src/uploader/providers/zora.ts
var ZoraUploader = class {
  constructor(creatorAddress) {
    this.creatorAddress = creatorAddress;
    if (!getApiKey()) {
      throw new Error("API key is required for metadata interactions");
    }
  }
  async getJWTApiKey() {
    if (this.jwtApiKey && this.jwtApiKeyExpiresAt && this.jwtApiKeyExpiresAt > Date.now()) {
      return this.jwtApiKey;
    }
    this.jwtApiKeyExpiresAt = Date.now() + 1e3 * 60 * 60;
    const response = await setCreateUploadJwt2({
      creatorAddress: this.creatorAddress
    });
    this.jwtApiKey = response.data?.createUploadJwtFromApiKey;
    if (!this.jwtApiKey) {
      throw new Error("Failed to create upload JWT");
    }
    return this.jwtApiKey;
  }
  async upload(file) {
    const jwtApiKey = await this.getJWTApiKey();
    const formData = new FormData();
    formData.append("file", file, file.name);
    const response = await fetch(
      "https://ipfs-uploader.zora.co/api/v0/add?cid-version=1",
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${jwtApiKey}`,
          Accept: "*/*"
        },
        body: formData
      }
    );
    if (!response.ok) {
      console.error(await response.text());
      throw new Error(`Failed to upload file: ${response.statusText}`);
    }
    const data = await response.json();
    return {
      url: `ipfs://${data.cid}`,
      size: data.size,
      mimeType: data.mimeType
    };
  }
};
function createZoraUploaderForCreator(creatorAddress) {
  return new ZoraUploader(creatorAddress);
}
export {
  CoinMetadataBuilder,
  CreateConstants,
  ZoraUploader,
  cleanAndValidateMetadataURI,
  createCoin,
  createCoinCall,
  createMetadataBuilder,
  createTradeCall,
  createZoraUploaderForCreator,
  getCoin2 as getCoin,
  getCoinComments2 as getCoinComments,
  getCoinCreateFromLogs,
  getCoinHolders2 as getCoinHolders,
  getCoinSwaps2 as getCoinSwaps,
  getCoins2 as getCoins,
  getCoinsLastTraded,
  getCoinsLastTradedUnique,
  getCoinsMostValuable,
  getCoinsNew,
  getCoinsTopGainers,
  getCoinsTopVolume24h,
  getCreatorCoins,
  getMostValuableCreatorCoins,
  getProfile2 as getProfile,
  getProfileBalances2 as getProfileBalances,
  getProfileCoins2 as getProfileCoins,
  getURLFromUploadResult,
  setApiKey,
  tradeCoin,
  updateCoinURI,
  updateCoinURICall,
  updatePayoutRecipient,
  updatePayoutRecipientCall,
  validateImageMimeType,
  validateMetadataJSON,
  validateMetadataURIContent
};
//# sourceMappingURL=index.js.map